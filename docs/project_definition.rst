Project definition
=================

Vision
------
Mozilla’s Continuous Integration Tools is intended to be a go-to framework to help us interact
in an easy and optimized manner with the various components of our CI. It helps both query
information generated by it as well as smartly scheduling jobs depending on the needs.

Some of what this project can potentially accomplish is:

* Trigger any jobs (builds, tests, nightly, L10n et al)
* Query any information related to our VCS systems
* Determine completeness of jobs run on a revision
* Find hidden jobs that are permanently wasting resources
* Help us bisect intermittent oranges
* Help us backfill any missing jobs
* Help us find any files/artifacts generated by any job in our CI

This year’s goal is to answer some of these needs based on Release Engineering’s current Buildbot CI.
In the near future, we should also be able to do the same for the TaskCluster CI.

In order to accomplish this we need to add the following basic features:

* Determine accurately the current state of jobs
* Determine the full set of jobs that can be run for a given revision
* Log jobs triggered in a consumable manner
* Allow a user monitor jobs triggered
* Create test framework to test the various CI data sources buildapi, buildjson, pushlog, treeherder

The remainder of this document will describe our roadmap and potentical use cases.
In order to understand better the data sources we use visit Data_Sources_.

Roadmap
-------
**NOTE** This roadmap is still working in progress.

Milestones
----------
Create prototype to trigger N jobs for a range of revisions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This allows backfilling jobs.

This has been accomplished on the 0.2.1 release (15/02/13).

Add pushlog support
^^^^^^^^^^^^^^^^^^^
This helps interact with ranges of revisions.

This has been accomplished on the 0.2.1 release (15/02/13).

Determine accurately the current state of jobs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We currently can determine some of this information through self-serve’s BuildAPI,
however, this system can sometimes not be available and might need to fall back to other data sources.

NOTE: As of 2015/02/10, this is close to be completed.
Determine the full set of jobs that can be run for a given revision
In order to determine how many jobs are missing from a given revision we need to
Log jobs triggered in a consumable manner
TBD

Allow a user monitor jobs triggered
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We currently trigger jobs and don’t have an standardized method to monitor such triggered jobs.
We have buildapi, buildjson and treeherder APIs as our candidates.

Test framework to test CI data sources
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Currently we can only test POST operations on the live systems which is far from ideal, however,
it is our current only option.

Use cases
---------

Case scenario 1: Bisecting permanent issue
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* We have a job failing
* There are jobs that were coalesced between the last good and the first bad
* We need to backfill between changeset-good to changeset-bad

NOTE: How to handle a green intermittent! (corner case)
NOTE: Consider not having a build job since it was broken for few changesets and then an issue came up.
NOTE: Consider if a job is canceled or PGO or nightly.

Case scenario 2: Bisecting intermittent issue
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* We have an intermittent job
* We want to determine when it started happening
* It is not only a matter of coalescing but also a matter of frequency
* We want to give a range of changesets and bisect until spotting culprit

NOTE: We trigger more than once compared to case scenario 1

Case scenario 3: Retrigger an intermittent job on a changeset until hit
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
https://bugzilla.mozilla.org/show_bug.cgi?id=844746

* This is more of an optimization.
* The intent is to hit the orange with extra debugging information.
* We're not bisecting in here.
* We can trigger batches (e.g. 5 at a time)

NOTE: Consider how to determine that the jobs have been completed (status of jobs)

Case scenario 4: Bisecting Talos
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* We have a performance regression
* We want to determine when it started showing up
* Given a revision that _failed_
* Re-trigger that revision three times and all revisions prior to it until the last data point + 1 more

Case scenario 5: After uplift we need a new baseline for release branches
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* We need several data points to establish a baseline
* After an uplift we need to generate a new baseline
* Once there is a baseline we can determine regression


Case scenario 6: New test validation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* New test validation
* re-triggering to determine indeterminacy
* Single revision
* All platforms running test

Case scenario 7: Fill in a changeset
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* We know that a changeset is missing jobs
* We want to add all missing jobs

FAQ
---
.. toctree::
   :maxdepth: 1

   faq

.. _Data_Sources: data_sources.html
